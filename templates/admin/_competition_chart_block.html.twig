{# This partial renders a single competition chart and handles its Mercure updates. #}
{#
Parameters:
- chart: The Symfony UX Chart object (required)
- mercureUrl: The Mercure subscribe URL for this specific chart's updates (required)
- competitionTitle: The title of the competition (required)
#}

<div class="chart-container" style="position: relative; height:300px;">
    {{ render_chart(chart) }}
</div>

{#
<script>
    document.addEventListener('DOMContentLoaded', function() {
        const chartId = '{{ chart.id }}'; // Unique ID generated by UX Chart.js
        const mercureUrl = '{{ mercureUrl | escape_js }}';
        const competitionTitle = '{{ competitionTitle | escape_js }}';

        const chartElement = document.getElementById(chartId);
        let chartInstance = null;

        if (!chartElement) {
            console.error(`Chart canvas element with ID ${chartId} not found.`);
            return;
        }

        // Use setInterval to check for chart initialization, as it's asynchronous.
        // This is a common pattern when interacting with UX Chart.js instances after initial render.
        let checkInterval = setInterval(() => {
            if (chartElement.__chartjs) {
                clearInterval(checkInterval); // Stop checking once found
                chartInstance = chartElement.__chartjs;
                console.log(`Chart ${chartId} initialized. Subscribing to Mercure: ${mercureUrl}`);
                subscribeToMercure(mercureUrl, chartInstance, competitionTitle);
            }
        }, 100); // Check every 100ms

        // Clean up interval on page unload
        window.addEventListener('beforeunload', function() {
            clearInterval(checkInterval);
        });

        // Function to subscribe to Mercure updates
        function subscribeToMercure(mercureUrl, chartInstance, title) {
            const eventSource = new EventSource(mercureUrl, { withCredentials: true });

            eventSource.onmessage = event => {
                const data = JSON.parse(event.data);
                console.log(`Mercure update received for ${title}:`, data);
                
                // Add new data point to the chart
                // Assuming data contains 'timestamp', 'initiated', 'processed'
                const timestamp = data.timestamp.substring(11, 16); // e.g., "HH:MM"
                
                chartInstance.data.labels.push(timestamp);
                
                // Update datasets: assuming datasets[0] is Initiated, datasets[1] is Processed
                chartInstance.data.datasets[0].data.push(data.initiated);
                chartInstance.data.datasets[1].data.push(data.processed);

                // Optional: Limit the number of data points to keep the graph readable
                const maxDataPoints = 60; // e.g., 60 points for 5-min snapshots = 5 hours
                if (chartInstance.data.labels.length > maxDataPoints) {
                    chartInstance.data.labels.shift(); // Remove oldest label
                    chartInstance.data.datasets[0].data.shift(); // Remove oldest initiated data
                    chartInstance.data.datasets[1].data.shift(); // Remove oldest processed data
                }

                // Update chart to redraw with new data
                chartInstance.update();
            };

            eventSource.onerror = error => {
                console.error('Mercure Error:', error);
                eventSource.close(); // Close the connection on error
            };

            // Close Mercure connection when the page is unloaded
            window.addEventListener('beforeunload', function() {
                eventSource.close();
            });
        }
    });
</script>
#}